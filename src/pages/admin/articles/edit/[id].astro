---
import MainLayout from '@/layouts/MainLayout.astro';
import { getArticleById } from '@/data/article';
import { getAllAuthors, getTourLeaders } from '@/data/author';
import { ArticleForm } from '@/components/form/ArticleForm';
import FormFeedback from '@/components/FormFeedback';

const { id } = Astro.params;
if (!id) return Astro.redirect('/admin/articles');

const article = await getArticleById(id);
if (!article) return Astro.redirect('/admin/articles');

const authors = await getAllAuthors();
const tourLeaders = await getTourLeaders();

// Convert ObjectId to string for React component
const articleData = {
  ...article,
  _id: article._id.toString(),
  author_id: article.author_id.toString(),
  tour_leader_id: article.tour_leader_id?.toString(),
  status: article.status,
};

const authorsData = authors.map(a => ({
  _id: a._id.toString(),
  name: a.name,
}));

const tourLeadersData = tourLeaders.map(tl => ({
  _id: tl._id.toString(),
  name: tl.name,
}));
---

<MainLayout title={`Modifica ${article.title}`}>
  <FormFeedback client:load isLoading={false} success={null} error={null} />
  <div class="p-8">
    <div class="max-w-5xl mx-auto">
      <h1 class="text-3xl font-bold text-gray-800 mb-6">Modifica Articolo</h1>
      
      <ArticleForm
        client:load
        article={articleData}
        authors={authorsData}
        tourLeaders={tourLeadersData}
        mode="edit"
      />
    </div>
  </div>
</MainLayout>

<script define:vars={{ articleId: id }}>
  let isLoading = false;

  function updateFeedback(props) {
    const event = new CustomEvent('formFeedback', { detail: props });
    window.dispatchEvent(event);
  }

  // Handle form submission - use capturing phase to catch React form events
  window.addEventListener('submit', async (e) => {
    const form = e.target;
    if (form.id === 'articleForm') {
      e.preventDefault();
      e.stopPropagation();
      
      console.log('Form submit intercepted');
      
      if (isLoading) return;
      isLoading = true;
      updateFeedback({ isLoading: true, success: null, error: null });
      
      const formData = new FormData(form);
      const data = {};
      
      const fileFields = new Set([
        'image_file',
        'image_hero_file',
        'video_full_file',
        'itinerary_image_file',
      ]);
      const mediaUploads = [];

      // Process form data
      formData.forEach((value, key) => {
        if (fileFields.has(key)) {
          if (value instanceof File && value.size > 0) {
            mediaUploads.push({ key, file: value });
          }
          return;
        }
        // Handle nested array fields like itinerary_items[0][title]
        const nestedMatch = key.match(/^(.+)\[(\d+)\]\[(.+)\]$/);
        if (nestedMatch) {
          const fieldName = nestedMatch[1];
          const index = parseInt(nestedMatch[2]);
          const subField = nestedMatch[3];
          
          if (!data[fieldName]) data[fieldName] = [];
          if (!data[fieldName][index]) data[fieldName][index] = {};
          data[fieldName][index][subField] = value;
        }
        // Handle simple array fields like tag_ids[0]
        else if (key.includes('[')) {
          const match = key.match(/^(.+)\[(\d+)\]$/);
          if (match) {
            const fieldName = match[1];
            if (!data[fieldName]) data[fieldName] = [];
            data[fieldName].push(value);
          }
        } else {
          data[key] = value;
        }
      });
      
      console.log('Sending data:', data);
      
      const uploadMedia = async (entityId, upload) => {
        const mediaType = upload.key === 'video_full_file' ? 'video' : 'image';
        const fieldMap = {
          image_file: 'image',
          image_hero_file: 'image_hero',
          video_full_file: 'video_full',
          itinerary_image_file: 'itinerary_image',
        };
        const field = fieldMap[upload.key];

        if (!field) return null;

        const presignResponse = await fetch('/admin/api/media/presign', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            filename: upload.file.name,
            contentType: upload.file.type,
          }),
        });

        if (!presignResponse.ok) {
          throw new Error('Impossibile generare la presigned URL');
        }

        const presign = await presignResponse.json();

        const uploadResponse = await fetch(presign.uploadUrl, {
          method: 'PUT',
          headers: presign.headers,
          body: upload.file,
        });

        if (!uploadResponse.ok) {
          throw new Error('Upload media fallito');
        }

        const finalizeResponse = await fetch('/admin/api/media/finalize', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            mediaType,
            tmpKey: presign.key,
            entity: 'article',
            entityId,
            field,
            filename: upload.file.name,
            contentType: upload.file.type,
          }),
        });

        if (!finalizeResponse.ok) {
          throw new Error('Finalize media fallito');
        }

        const finalize = await finalizeResponse.json();
        return { field, media: finalize.media };
      };

      try {
        const response = await fetch(`/admin/api/articles/${articleId}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        });
        
        if (response.ok) {
          if (mediaUploads.length > 0) {
            const mediaUpdates = {};
            for (const upload of mediaUploads) {
              const result = await uploadMedia(articleId, upload);
              if (result) {
                mediaUpdates[result.field] = result.media;
              }
            }
            if (Object.keys(mediaUpdates).length > 0) {
              await fetch(`/admin/api/articles/${articleId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(mediaUpdates),
              });
            }
          }
          isLoading = false;
          updateFeedback({ 
            isLoading: false, 
            success: { show: true, message: 'Articolo aggiornato con successo!' }, 
            error: null 
          });
        } else {
          const error = await response.json();
          isLoading = false;
          updateFeedback({ 
            isLoading: false, 
            success: null, 
            error: { show: true, message: error.message || 'Impossibile aggiornare l\'articolo' } 
          });
        }
      } catch (error) {
        console.error('Error updating article:', error);
        isLoading = false;
        updateFeedback({ 
          isLoading: false, 
          success: null, 
          error: { show: true, message: 'Errore durante l\'aggiornamento dell\'articolo' } 
        });
      }
    }
  }, true); // Use capture phase
</script>
